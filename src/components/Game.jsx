import React from 'react';
import Tile from './Tile';
import '../styles/Game.css';
import nextIcon from '../images/next.png';
import shuffleIcon from '../images/shuffle.png';
import resetIcon from '../images/reset.png';

export default class Game extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			width: 0, //dimension of one side
			tiles: {}, //An object which holds keys and value pairs for each tile. Since this will be treated as an array, it will be referred to as the tile array
			solved: false, //puzzle is solved value
			moves: 0, //valid clicks player makes
			completed: 0, //number of puzzles completed
		};
	}

	//calls restart function to initialize the puzzle when the component is first mounted
	componentDidMount() {
		this.restartPuzzle();
	}

	//creates an ordered object of numbers to populate the tiles
	//takes the input width and generates an object containing corresponding key and string value pairs for all tile numbers
	//lists generated by this function are always ordered, with the last key being the empty string value.
	//returns the ordered object
	genTile(width) {
		let i;
		let array = {};

		//populates the object with key :: value pairs
		for (i = 0; i < width * width - 1; i++) { //initializes tile numbers 1 to last-1. e.g. 1-8 for a 9 tile puzzle
			Object.assign(array, { [i.toString()]: (i + 1).toString() }); //s.t. value = key+1
		}

		//the last tile will always be blank at the start of the puzzle
		Object.assign(array, { [i.toString()]: '' });

		return array;
	}

	//takes the object containing the tiles and then reshuffles it
	//this function uses a basic randomization loop to swap number positions
	//swaps the key values in such a way that the values are no longer ordered
	//returns the shuffled object
	shuffle(array) {
		let ran, temp; //random, temporary. Used to store values when swapping
		let curr = Object.keys(array).length - 1; //starts with the last non-empty tile space
		//cycles through keys in the object, each key will have its value swapped at least once
		while (curr !== 0) {
			//gets random key to swap with
			ran = Math.floor(Math.random() * curr--);

			//swap the values of the current key and the random key
			temp = array[curr.toString()];
			array[curr.toString()] = array[ran.toString()];
			array[ran.toString()] = temp;
		}

		return array;
	}

	//checks if the input object key value pairs are ordered
	//this function iterates through each key, checking if it contains the appropriate value for an ordered list
	//returns a boolean value if all keys have the correct value
	ordered(array) {
		let i;
		let length = Object.keys(array).length - 1;

		for (i = 0; i < length; i++) {
			//if value is not ordered, invalid
			if (parseInt(array[i.toString()]) !== i + 1) {
				return false;
			}
		}

		return true;
	}

	//checks the solvability of a given puzzle
	//takes in an object and a width number value, the default value being the current state width
	//checks the solvability of the puzzle by checking the number of value inversions in the object's key value pairs
	//returns true or false depending on if the puzzle is solvable or not, respectively
	solvable(array, width = this.state.width) {
		//we don't want to bother checking the solvability of puzzles that are too small
		if (width < 3){
			return true; //return true by default to prevent a potential infinite loop in the reset function
		}

		let i, j; //i, j used to keep track of the current keys
		let inversions = 0; //the inversion counter used to determine if a puzzle is solvable
		let blankPos = width * width - 1; //stores the key for the blank position

		for (i = 0; i < width * width - 1; i++) {
			for (j = i + 1; j < width * width; j++) { //i key will always be less than j key
				//first, we need to check if the blank position has moved
				if (array[i.toString()] === '') { // if the current value is blank, we want to save this key
					blankPos = i;
				}
				//counts number of inversions. Inversions are when numbers appear out of order
				//if the value in i is actually greater than j, then an inversion has occurred.
				if (
					array[j.toString()] !== '' &&
					array[i.toString()] !== '' &&
					parseInt(array[i.toString()]) > parseInt(array[j.toString()])
				) {
					inversions += 1;
				}
			}
		}

		//puzzle solvability depends on if the width is even or odd
		//if ODD, the puzzle is solvable when the number of inversions is EVEN
		if (width % 2 === 1) {
			if (inversions % 2 === 0) {
				return true;
			}
		}
		//if EVEN,
		//the puzzle is solvable when the blank is on an ODD numbered row and the number of inversions is EVEN
		//OR, the puzzle is solvable when the blank is on an EVEN numbered row and the number of inversions is EVEN
		else if (parseInt((blankPos / width) % 2) === 1) { //odd row
			if (inversions % 2 === 0) {//even num
				return true;
			}
		} else { //even row
			if (inversions % 2 === 1) { //odd num
				return true;
			}
		}

		//In any other case, the puzzle is not solvable
		return false;
	}

	//creates a new puzzle based on the input width, and resets the state values to reflect a new puzzle
	//this function does not reset the completed value in state
	reset(width = this.state.width) {
		let array = this.genTile(width); //generate a new object for the puzzle
		//shuffle the puzzle until it is no longer ordered or unsolvable
		while (this.solvable(array, width) === false || this.ordered(array) === true) {
			array = this.shuffle(array);
		}
		//reset the values in state for the new puzzle
		this.setState({
			width: width,
			moves: 0,
			solved: false,
			tiles: array
		});

		return array;
	}

	//create the next puzzle, increasing the width
	//will not create a puzzle with a width bigger than 6
	nextPuzzle() {
		if (this.state.solved && this.state.width < 6) {
			this.reset(this.state.width + 1);
		}
		else if (this.state.width >= 6){
			this.reset(this.state.width);
		}
	}

	//this function completely resets the puzzle game to the beginning
	//this is the only way to reset the completed count
	restartPuzzle() {
		//the first puzzle is always a 3 by 3, 8 tile
		this.reset(3);
		this.setState({completed: 0});
	}

	//returns the key which holds a given value
	getKeyByValue(tileNumber) {
		return Object.keys(this.state.tiles).find(
			(key) => this.state.tiles[key] === tileNumber,
		);
	}

	//the button click handler for tiles
	//this function determines if the click was on a valid tile and if it is movable
	//then, it will move the tile to the correct location and then update the state accordingly
	//this is the only place where completed count and solved booleans are updated
	handleClick = (tileNumber) => {
		//do not allow the tiles to be moved if the puzzle has been sovled
		if (this.state.solved) {
			return;
		}

		const blank_key = this.getKeyByValue('');
		const tile_key = this.getKeyByValue(tileNumber);
		let bk_num = parseInt(blank_key);
		let tk_num = parseInt(tile_key);
		let width = this.state.width;
		let tiles = this.state.tiles;
		//only allow movement on tiles adjacent to the blank space
		if (
			Math.abs(bk_num - tk_num) === 1 ||
			Math.abs(bk_num - tk_num) === width
		) {
			//check for edge violation, making sure the clicked tile is actually movable
			if (
				(bk_num % width !== 0 || tk_num % width !== width - 1) &&
				(tk_num % width !== 0 || bk_num % width !== width - 1)
			) {
				//when all conditions are met, complete movement for the clicked tile
				//swap the keys so that the blank and tile values are in their new positions
				tiles[blank_key] = tileNumber;
				tiles[tile_key] = '';
				//update state to reflect any changes to the puzzle status
				let solved = this.ordered(this.state.tiles);
				let completed = this.state.completed;
				if (solved){
					completed += 1;
				}

				this.setState({
					moves: this.state.moves + 1,
					completed: completed,
					solved: solved,
					tiles: tiles,
				});
			}
		}
	};

	//the following three functions are used to generate a square grid for a given width, populated using the tiles object
	renderTile(tileNumber) {	//creates an individual tile, passing the tile number and current width for styling purposes
		return (
			<Tile rowWidth={this.state.width} label={this.state.tiles[tileNumber]} onClick={this.handleClick} key={tileNumber}/>
		);
	}

	renderRows(tileNumber) { //creates the tiles on the current row, for a given width
		let width = this.state.width;
		let row = [];
		let i;
		for (i = 0; i < width; i++) {
			row.push(this.renderTile(tileNumber++));
		}

		return row;
	}

	renderCols(tileNumber) { //creates and stacks a number of rows for a given height
		let height = this.state.width; //because the puzzle is a square, height and width are equivalent
		let cols = [];
		let i;
		let tNum = parseInt(tileNumber); //makes the tile number iterable for the loop
		for (i = 0; i < height; i++) {
			cols.push(
				<div className="GameRow" key={(tNum * -1).toString()}>
					{this.renderRows(tNum.toString())}
				</div>,
			);
			tNum += height; //iterate by height, skipping the tile numbers in the current row
		}
		return cols;
	}

	render() {
		return (
			<div className="Game" align="center">
				<div className="GameStats">
					<h2>Completed: {this.state.completed}</h2>
					<h2>Moves: {this.state.moves}</h2>
				</div>
				<div className="GameBoard">{this.renderCols('0')}</div>
				<div className="GameInterface">
					<button style={{float: "left"}}
						onClick={() => {
							this.restartPuzzle();
						}}>
						<img src={resetIcon} alt="Restart"/>
					</button>
					<button
						onClick={() => {
							this.reset();
						}}>
						<img src={shuffleIcon} alt="Shuffle"/>
					</button>
					<button style={{float: "right"}}
						onClick={() => {
							this.nextPuzzle();
						}}>
						<img src={nextIcon} alt="Next"/>
					</button>
				</div>
			</div>
		);
	}
}
